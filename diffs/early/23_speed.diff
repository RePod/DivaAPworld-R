diff --git a/Client.py b/Client.py
index 4c2f91d..8b9fdb4 100644
--- a/Client.py
+++ b/Client.py
@@ -13,7 +13,6 @@ from .DataHandler import (
     song_unlock,
     generate_modded_paths,
     create_copies,
-    another_song_replacement,
     restore_originals,
     restore_song_list,
 )
@@ -131,7 +130,6 @@ class MegaMixContext(CommonContext):
                 self.mod_pv_list = generate_modded_paths(self.modData, self.path)
             self.mod_pv_list.append(self.mod_pv)
             create_copies(self.mod_pv_list)
-            another_song_replacement(self.mod_pv_list)
             asyncio.create_task(self.send_msgs([{"cmd": "GetDataPackage", "games": ["Hatsune Miku Project Diva Mega Mix+"]}]))
             self.check_goal()
 
@@ -181,11 +179,12 @@ class MegaMixContext(CommonContext):
         for pack, songs in self.modData.items():  # Iterate through each pack
             for song in songs:  # Iterate through each song in the pack
                 if song[1] == target_song_id:
-                    return True, pack.replace('/', "'")  # Return True and the song pack name
-        return False, None
+                    return pack
+        return "ArchipelagoMod"
 
     async def receive_item(self):
         async with self.critical_section_lock:
+            ids_to_packs = {}
 
             for network_item in self.items_received:
                 if network_item not in self.previous_received:
@@ -197,30 +196,23 @@ class MegaMixContext(CommonContext):
                         # Maybe move static items out of MegaMixCollection instead of hard coding?
                         pass
                     else:
-                        if self.modded:
-                            found, song_pack = self.is_item_in_modded_data(network_item.item)
-                        else:
-                            found = False
-                            song_pack = None
-                        if found:
-                            song_unlock(self.path, network_item.item, False, True, song_pack)
-                        else:
-                            song_unlock(self.mod_pv, network_item.item, False, False, song_pack)
+                        song_pack = self.is_item_in_modded_data(network_item.item) if self.modded else "ArchipelagoMod"
+
+                        if song_pack not in ids_to_packs:
+                            ids_to_packs[song_pack] = []
+                        ids_to_packs[song_pack].append(network_item.item)
+
+            for song_pack in ids_to_packs:
+                song_unlock(self.path, ids_to_packs.get(song_pack), False, song_pack)
+
 
     def check_goal(self):
-        if self.leeks_obtained >= self.leeks_needed:
-            if not self.sent_unlock_message:
-                logger.info(f"Got enough leeks! Unlocking goal song: {self.goal_song}")
-                self.sent_unlock_message = True
-            if self.modded:
-                found, song_pack = self.is_item_in_modded_data(self.goal_id)
-            else:
-                found = False
-                song_pack = None
-            if found:
-                song_unlock(self.path, self.goal_id, False, True, song_pack)
-            else:
-                song_unlock(self.mod_pv, self.goal_id, False, False, song_pack)
+        if not self.sent_unlock_message and self.leeks_obtained >= self.leeks_needed:
+            self.sent_unlock_message = True
+            logger.info(f"Got enough leeks! Unlocking goal song: {self.goal_song}")
+            song_pack = self.is_item_in_modded_data(self.goal_id) if self.modded else "ArchipelagoMod"
+            song_unlock(self.path, [self.goal_id], False, song_pack)
+
 
     async def watch_json_file(self, file_name: str):
         """Watch a JSON file for changes and call the callback function."""
@@ -331,24 +323,23 @@ class MegaMixContext(CommonContext):
             logger.info("Auto Remove Set to Off")
 
     async def remove_songs(self):
-
         group_songs = {}
         for loc in self.prev_found:
             prefix, last = divmod(loc, 10)
             group_songs.setdefault(prefix, set()).add(last)
         finished_songs = [prefix * 10 for prefix, digits in group_songs.items() if {0, 1} <= digits]
+        ids_to_packs = {}
 
         # Check for matches where all suffixes have been found
         for item in finished_songs:
-            if self.modded:
-                found, song_pack = self.is_item_in_modded_data(item)
-            else:
-                found = False
-                song_pack = None
-            if found:
-                song_unlock(self.path, item, True, True, song_pack)
-            else:
-                song_unlock(self.mod_pv, item, True, False, song_pack)
+            song_pack = self.is_item_in_modded_data(item) if self.modded else "ArchipelagoMod"
+
+            if song_pack not in ids_to_packs:
+                ids_to_packs[song_pack] = []
+            ids_to_packs[song_pack].append(item)
+
+        for song_pack in ids_to_packs:
+            song_unlock(self.path, ids_to_packs.get(song_pack), True, song_pack)
 
         logger.info("Removed songs!")
 
diff --git a/DataHandler.py b/DataHandler.py
index dc131f4..bd16a0e 100644
--- a/DataHandler.py
+++ b/DataHandler.py
@@ -117,7 +117,6 @@ def process_json_data(json_data):
 
 
 def generate_modded_paths(processed_data, base_path):
-
     # Extract unique pack names from processed_data
     unique_pack_names = {pack_name.replace('/', "'") for pack_name, songs in processed_data.items()}
 
@@ -126,185 +125,50 @@ def generate_modded_paths(processed_data, base_path):
     return list(modded_paths)
 
 
-def restore_song_list(file_paths, skip_ids, restore):
-    skip_ids.extend([144, 700])  # Append 144,and 700 to the skip_ids list
-    for file_path in file_paths:
-        with open(file_path, 'r', encoding='utf-8') as file:
-            modified_lines = []
-            for line in file:
-                if line.startswith("pv_"):
-                    song_numeric_id = re.search(r'pv_(\d+)', line)
-                    if song_numeric_id:
-                        song_numeric_id = int(song_numeric_id.group(1))
-                        if song_numeric_id in skip_ids:
-                            modified_lines.append(line)
-                            continue
-                        else:
-                            if restore:
-                                line = re.sub(r'(\.difficulty\.(easy|normal|hard)\.length)=\d+', r'\1=1', line)
-                                line = re.sub(r'(\.difficulty\.extreme\.length)=\d+', r'\1=2', line)
-                                # Only modify the line if it ends with an equals sign
-                                if re.match(r'(pv_\d+\.difficulty\.extreme\.0\.script_file_name)=$', line.strip()):
-                                    line = f"pv_{song_numeric_id}.difficulty.extreme.0.script_file_name=rom/script/pv_{song_numeric_id}_extreme_0.dsc\n"
-                            else:
-                                line = re.sub(r'(\.difficulty\.(easy|normal|hard|extreme)\.length)=\d+', r'\1=0', line)
-                modified_lines.append(line)
-
-        with open(file_path, 'w', encoding='utf-8') as file:
-            file.writelines(modified_lines)
-
-
-def erase_song_list(file_paths):
-    difficulty_replacements = {
-        "easy.length=1": "easy.length=0",
-        "normal.length=1": "normal.length=0",
-        "hard.length=1": "hard.length=0",
-        "extreme.length=1": "extreme.length=0",
-        "extreme.length=2": "extreme.length=0",
-    }
+def restore_song_list(file_paths):
+    search = re.compile(r"^#ARCH#(.*)", re.MULTILINE)
 
     for file_path in file_paths:
-        # Read file content
-        with open(file_path, 'r', encoding='utf-8') as file:
-            file_data = file.readlines()
+        with open(file_path, 'r+', encoding='utf-8') as file:
+            file_data = re.sub(search, r"\g<1>", file.read())
+            file.seek(0)
+            file.write(file_data)
+            file.truncate()
 
-        # Perform replacements
-        for i, line in enumerate(file_data):
-            # Skip mod song and tutorial IDs
-            if re.match(r'^pv_(144|700)\.', line):
-                continue
-            for search_text, replace_text in difficulty_replacements.items():
-                file_data[i] = file_data[i].replace(search_text, replace_text)
-
-        # Rewrite file with replacements
-        with open(file_path, 'w', encoding='utf-8') as file:
-            file.writelines(file_data)
 
+def erase_song_list(file_paths):
+    search = re.compile(r"^(pv_(?!(144|700)\.)\d+\.difficulty\.(?:easy|normal|hard|extreme)\.length=\d)$", re.MULTILINE)
 
-def another_song_replacement(file_paths):
     for file_path in file_paths:
-        # Read file content
-        with open(file_path, 'r', encoding='utf-8') as file:
-            file_data = file.readlines()
-
-        # Dictionary to store song names in English for each pv_x
-        song_names_en = {}
-
-        # Regex patterns
-        pv_pattern = re.compile(r'^pv_(\d+)\..*')
-        song_name_en_pattern = re.compile(r'^pv_(\d+)\.song_name_en=(.*)')
-        another_song_name_en_pattern = re.compile(r'^pv_(\d+)\.another_song\.\d+\.name_en=.*')
-
-        # Find all pv_x identifiers and their corresponding song names
-        for line in file_data:
-            pv_match = pv_pattern.match(line)
-            if pv_match:
-                pv_id = pv_match.group(1)
-                song_name_en_match = song_name_en_pattern.match(line)
-                if song_name_en_match:
-                    song_names_en[pv_id] = song_name_en_match.group(2)
-
-        # Replace name_en values for each pv_x
-        updated_file_data = []
-        for line in file_data:
-            another_song_match = another_song_name_en_pattern.match(line)
-            if another_song_match:
-                pv_id = another_song_match.group(1)
-                if pv_id in song_names_en:
-                    # Replace the content after '=' with the stored song_name_en
-                    updated_line = re.sub(r'=(.*)', f'={song_names_en[pv_id]}', line)
-                    updated_file_data.append(updated_line)
-                else:
-                    updated_file_data.append(line)
-            else:
-                updated_file_data.append(line)
+        with open(file_path, 'r+', encoding='utf-8') as file:
+            file_data = re.sub(search, r"#ARCH#\g<1>", file.read())
+            file.seek(0)
+            file.write(file_data)
+            file.truncate()
 
-        # Write the updated content back to the file
-        with open(file_path, 'w', encoding='utf-8') as file:
-            file.writelines(updated_file_data)
 
-
-# Text Replacement
-def replace_line_with_text(file_path, search_text, new_line):
-    try:
-        # Read the file content with specified encoding
-        with open(file_path, 'r', encoding='utf-8') as file:
-            lines = file.readlines()
-    except UnicodeDecodeError:
-        logger.debug(f"Error: Unable to decode file '{file_path}' with UTF-8 encoding.")
-        return
-
-    # Find and replace the line containing the search text
-
-    j = 0
-    for i, line in enumerate(lines):
-        if search_text in line:
-            lines[i] = new_line + '\n'
-            break
-    else:
-        # If the search text was not found, logger.debug an error and return
-        j += 1
-        logger.debug(f"Error: '{search_text}' not found in the file.")
-        return
-
-    logger.debug(f"Unable to find {j} Search texts in file")
-    # Write the modified content back to the file
-    with open(file_path, 'w', encoding='utf-8') as file:
-        file.writelines(lines)
-
-
-def song_unlock(file_path, item_id, lock_status, modded, song_pack):
+def song_unlock(file_path, item_id, lock_status, song_pack):
     """Unlock a song based on its id"""
 
-    song_id = int(item_id) // 10
-
     # Select the appropriate action based on lock status
     action = modify_mod_pv if not lock_status else remove_song
-    if modded:
+    song_ids = "|".join([str(x // 10).zfill(3) for x in item_id])
+    if song_pack is not None:
         file_path = f"{file_path}/{song_pack}/rom/mod_pv_db.txt"
 
-    action(file_path, int(song_id))
+    with open(file_path, 'r+', encoding='utf-8') as file:
+        pv_db = action(file.read(), song_ids)
+        file.seek(0)
+        file.write(pv_db)
+        file.truncate()
 
-    return
 
+def modify_mod_pv(pv_db: str, songs: str) -> str:
+    return re.sub(rf"^#ARCH#(pv_({songs})\.difficulty\.(?:easy|normal|hard|extreme).length=\d)$", r"\g<1>", pv_db, flags=re.MULTILINE)
 
-def modify_mod_pv(file_path, song_id):
 
-    # Replace text to disable song
-    difficulties = ['easy', 'normal', 'hard', 'extreme']
-
-    for difficulty in difficulties:
-        search_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty." + difficulty + ".length=0"
-        replace_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty." + difficulty + ".length="
-
-        if difficulty == 'extreme':
-            replace_text += "2"
-        else:
-            replace_text += "1"
-
-        replace_line_with_text(file_path, search_text, replace_text)
-
-        if difficulty == 'extreme':
-            # Restore extreme
-            search_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty." + "extreme" + ".0.script_file_name="
-            replace_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty." + "extreme" + ".0.script_file_name=" + "rom/script/" + "pv_" + '{:03d}'.format(song_id) + "_extreme.dsc"
-            replace_line_with_text(file_path, search_text, replace_text)
-
-
-def remove_song(file_path, song_id):
-
-    # Replace text to disable song
-    difficulties = ['easy', 'normal', 'hard', 'extreme', 'exExtreme']
-
-    for difficulty in difficulties:
-        if difficulty == 'exExtreme':
-            search_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty.extreme.length=2"
-            replace_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty.extreme.length=0"
-        else:
-            search_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty." + difficulty + ".length=1"
-            replace_text = "pv_" + '{:03d}'.format(song_id) + ".difficulty." + difficulty + ".length=0"
-
-        replace_line_with_text(file_path, search_text, replace_text)
+def remove_song(pv_db: str, songs: str) -> str:
+    return re.sub(rf"^(pv_({songs})\.difficulty\.(?:easy|normal|hard|extreme).length=\d)$", r"#ARCH#\g<1>", pv_db, flags=re.MULTILINE)
 
 
 def extract_mod_data_to_json() -> list[Any]:
@@ -356,7 +220,7 @@ def extract_mod_data_to_json() -> list[Any]:
 
     return all_mod_data
 
-  
+
 def get_player_specific_ids(mod_data):
     song_ids = []  # Initialize an empty list to store song IDs
 
diff --git a/Options.py b/Options.py
index cfe3247..89ccfdd 100644
--- a/Options.py
+++ b/Options.py
@@ -177,7 +177,7 @@ class ModData(FreeText):
     """If you are using modded songs, delete the option below entirely and paste the string from the DivaJSON Tool here"""
     display_name = "MegaMixModData"
     default = ''
-    visibility = 0b1001
+    visibility = Visibility.template | Visibility.spoiler
 
 
 @dataclass
diff --git a/__init__.py b/__init__.py
index b5bb357..640247a 100644
--- a/__init__.py
+++ b/__init__.py
@@ -92,7 +92,7 @@ class MegaMixWorld(World):
                 raise ValueError(f"Not enough songs available. Need at least {self.options.starting_song_count + self.options.additional_song_count + 1}")
 
             # Handle goal ID
-            self.victory_song_id = available_song_keys[chosen_song_index].songID
+            self.victory_song_id = available_song_keys[chosen_song_index].songID * 10
             del available_song_keys[chosen_song_index]
 
             available_song_keys = self.handle_plando(available_song_keys)
