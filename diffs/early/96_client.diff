diff --git a/Client.py b/Client.py
index ffcc3ae..7241ee1 100644
--- a/Client.py
+++ b/Client.py
@@ -89,7 +89,6 @@ class MegaMixContext(SuperContext):
         self.modded = False
         self.freeplay = False
         self.mod_pv_list = []
-        self.previous_received = []
         self.sent_unlock_message = False
 
         self.items_handling = 0b001 | 0b010 | 0b100  #Receive items from other worlds, starting inv, and own items
@@ -99,12 +98,10 @@ class MegaMixContext(SuperContext):
         self.item_name_to_ap_id = None
         self.item_ap_id_to_name = None
         self.checks_per_song = 2
-        self.found_checks = []
-        self.missing_checks = []  # Stores all location checks found, for filtering
-        self.prev_found = []
 
         self.seed_name = None
         self.options = None
+        self.remap = None
 
         self.goal_song = None
         self.goal_id = None
@@ -139,10 +136,9 @@ class MegaMixContext(SuperContext):
 
             self.sent_unlock_message = False
             self.leeks_obtained = 0
-            self.missing_checks = args["missing_locations"]
-            self.prev_found = args["checked_locations"]
             self.location_ids = set(args["missing_locations"] + args["checked_locations"])
             self.options = args["slot_data"]
+            self.remap = self.options.get("modRemap", {})
             self.goal_song = self.options["victoryLocation"]
             self.goal_id = self.options["victoryID"]
             self.autoRemove = self.options["autoRemove"]
@@ -171,18 +167,16 @@ class MegaMixContext(SuperContext):
                 time.sleep(1)
 
         if cmd == "ReceivedItems":
-            # If receiving an item, only append that item
-            asyncio.create_task(self.receive_item())
+            asyncio.create_task(self.receive_item(args.get("index", 0)))
 
         if cmd == "RoomInfo":
             self.seed_name = args['seed_name']
 
-        elif cmd == "DataPackage":
+        if cmd == "DataPackage":
             if not self.location_ids:
                 # Connected package not recieved yet, wait for datapackage request after connected package
                 return
             self.leeks_obtained = 0
-            self.previous_received = []
 
             self.location_name_to_ap_id = args["data"]["games"]["Hatsune Miku Project Diva Mega Mix+"]["location_name_to_id"]
             self.location_name_to_ap_id = {
@@ -197,6 +191,10 @@ class MegaMixContext(SuperContext):
             # If receiving data package, resync previous items
             asyncio.create_task(self.receive_item())
 
+        if cmd == "RoomUpdate":
+            if "checked_locations" in args:
+                pass
+
     def song_id_to_pack(self, item_id):
         target_song_id = int(item_id) // 10
 
@@ -206,35 +204,31 @@ class MegaMixContext(SuperContext):
                     return pack
         return "ArchipelagoMod"
 
-    async def receive_item(self):
+    async def receive_item(self, index: int = 0):
+        if index == 0:
+            self.leeks_obtained = 0
+
         async with self.critical_section_lock:
             ids_to_packs = {}
 
-            for network_item in self.items_received:
-                if network_item not in self.previous_received:
-                    self.previous_received.append(network_item)
-                    if network_item.item == 1:
-                        self.leeks_obtained += 1
-                        self.check_goal()
-                    elif network_item.item == 2:
-                        # Maybe move static items out of MegaMixCollection instead of hard coding?
-                        pass
-                    elif network_item.item == 4:
-                        if not os.path.isfile(self.trapHiddenLocation):
-                            Path(self.trapHiddenLocation).touch()
-                    elif network_item.item == 5:
-                        if not os.path.isfile(self.trapSuddenLocation):
-                            Path(self.trapSuddenLocation).touch()
-                    elif network_item.item == 9:
-                        if not os.path.isfile(self.trapIconLocation):
-                            Path(self.trapIconLocation).touch()
-                    else:
-                        ids_to_packs.setdefault(self.song_id_to_pack(network_item.item), set()).add(network_item.item)
+            for network_item in self.items_received[index:]:
+                if network_item.item >= 10:
+                    ids_to_packs.setdefault(self.song_id_to_pack(network_item.item), set()).add(network_item.item)
+                elif network_item.item == 1:
+                    self.leeks_obtained += 1
+                    self.check_goal()
+                elif network_item.item == 2:
+                    pass # Filler
+                elif network_item.item == 4:
+                    Path(self.trapHiddenLocation).touch()
+                elif network_item.item == 5:
+                    Path(self.trapSuddenLocation).touch()
+                elif network_item.item == 9:
+                    Path(self.trapIconLocation).touch()
 
             for song_pack in ids_to_packs:
                 song_unlock(self.path, ids_to_packs.get(song_pack), False, song_pack)
 
-
     def check_goal(self):
         if not self.leek_label:
             from kivymd.uix.label import MDLabel
@@ -311,11 +305,13 @@ class MegaMixContext(SuperContext):
             logger.info("No checks to send at BK but seeing this means your Client is OK!")
             return
 
-        location_id = int(song_data.get('pvId') * 10)
+        # Check for remaps
+        song_id = song_data.get('pvId')
+        location_id = self.remap.get(str(song_id), song_id * 10)
         location_checks = set(range(location_id, location_id + self.checks_per_song))
 
         if not location_id == self.goal_id:
-            if location_checks.issubset(set(self.prev_found)):
+            if location_checks.issubset(set(self.checked_locations)):
                 logger.info("No checks to send: Song checks previously sent or collected")
                 return
 
@@ -330,10 +326,7 @@ class MegaMixContext(SuperContext):
 
             logger.info("Cleared song with appropriate grade!")
 
-            for i in range(2):
-                self.found_checks.append(location_id + i)
-
-            asyncio.create_task(self.send_checks())
+            asyncio.create_task(self.send_checks(location_checks))
         else:
             logger.info(f"Song {song_data.get('pvName')} was not beaten with a high enough grade")
 
@@ -350,50 +343,22 @@ class MegaMixContext(SuperContext):
 
         await self.send_msgs(message)
 
-    async def send_checks(self):
-        message = [{"cmd": 'LocationChecks', "locations": self.found_checks}]
-        await self.send_msgs(message)
-        self.remove_found_checks()
-        self.found_checks.clear()
+    async def send_checks(self, locations: set):
+        await self.check_locations(locations)
         if self.autoRemove and not self.freeplay:
             await self.remove_songs()
 
-    def remove_found_checks(self):
-        self.prev_found += self.found_checks
-        self.missing_checks = [item for item in self.missing_checks if item not in self.found_checks]
-
     async def get_uncleared(self):
+        prev_items = {i for item in self.items_received for i in (item.item, item.item + 1)}
+        missing_locations = {loc // 10 for loc in self.missing_locations if loc in prev_items}
 
-        prev_items = []
-        missing_locations = set()  # Convert to set if it's not already
-        logged_pairs = set()  # To keep track of logged pairs
-
-        # Get a list of all item names that have been received
-        for network_item in self.previous_received:
-            item_id = network_item.item // 10
-            prev_items.append(item_id)
-
-        for location in self.missing_checks:
-            # Change location name to match item name
-            if location not in missing_locations:
-                if location // 10 in prev_items:
-                    missing_locations.add(location)
-
-        # Now log pairs of locations
-        for location in missing_locations:
-            pair_last_digit = location % 2
-            paired_location = location - pair_last_digit + (1 - pair_last_digit)  # Flip last digit
-
-            # Only log if the pair hasn't been logged yet
-            pair_key = (min(location, paired_location), max(location, paired_location))
-            if pair_key not in logged_pairs:
-                logger.info(f"{self.location_ap_id_to_name[location][:-2]} is uncleared")
-                logged_pairs.add(pair_key)
+        for location in sorted(missing_locations):
+            location = self.remap.get(str(location), location * 10)
+            logger.info(f"{self.item_ap_id_to_name[location]} is uncleared")
 
         if self.leeks_obtained >= self.leeks_needed:
             logger.info(f"Goal song: {self.goal_song} is unlocked.")
 
-        # Check goal and if missingLocations is empty
         if not missing_locations:
             logger.info("All available songs cleared")
 
@@ -411,7 +376,8 @@ class MegaMixContext(SuperContext):
             logger.info("Auto Remove Set to Off")
 
     async def remove_songs(self):
-        finished_songs = self.prev_found[::self.checks_per_song]
+        missing = {songID // 10 for songID in self.missing_locations}
+        finished_songs = {songID for songID in self.checked_locations - self.missing_locations if songID // 10 not in missing}
 
         ids_to_packs = {}
         for item in finished_songs:
@@ -425,12 +391,11 @@ class MegaMixContext(SuperContext):
     async def freeplay_toggle(self):
         self.freeplay = not self.freeplay
 
-        song_ids = {location_id for location_id in sorted(self.location_ids)[::self.checks_per_song]
-                    if location_id not in [i.item for i in self.previous_received]}
+        received = {recv.item // 10 for recv in self.items_received if recv.item >= 10}
+        song_ids = {loc for loc in self.location_ids if loc // 10 not in received}
 
         if not self.freeplay:
-            song_ids = {received.item for received in self.previous_received if received.item in self.missing_checks}
-
+            song_ids = received
             if self.leeks_obtained >= self.leeks_needed:
                 song_ids.add(self.goal_id)
         elif self.leeks_obtained < self.leeks_needed:
diff --git a/DataHandler.py b/DataHandler.py
index f1fcbe2..5c8897e 100644
--- a/DataHandler.py
+++ b/DataHandler.py
@@ -12,6 +12,7 @@ import filecmp
 from typing import Any
 
 from .MegaMixSongData import dlc_ids
+from .SymbolFixer import format_song_name
 
 # Set up logger
 logging.basicConfig(level=logging.DEBUG)
@@ -30,7 +31,7 @@ def game_paths() -> dict[str, str]:
     dml_config = os.path.join(game_path, "config.toml")
     if os.path.isfile(dml_config):
         with open(dml_config, "r") as f:
-            mod_line = re.search(r"""^mods\s*=\s*['"](.*?)['"]""", f.read())
+            mod_line = re.search(r"""^mods\s*=\s*['"](.*?)['"]""", f.read(), re.MULTILINE)
             if mod_line:
                 mods_path = os.path.join(game_path, mod_line.group(1))
 
@@ -202,7 +203,7 @@ def extract_mod_data_to_json() -> list[Any]:
                             matches = re.findall(mod_data_pattern, file_content)
 
                             # Process each mod_data block
-                            for _ in matches:
+                            if matches:
                                 for single_yaml in yaml.safe_load_all(file_content):
                                     mod_data_content = single_yaml.get("Hatsune Miku Project Diva Mega Mix+", {}).get("megamix_mod_data", None)
 
@@ -219,17 +220,20 @@ def extract_mod_data_to_json() -> list[Any]:
     return all_mod_data
 
 
-def get_player_specific_ids(mod_data):
-    song_ids = []  # Initialize an empty list to store song IDs
-
-    if mod_data == "":
-        return {}, song_ids
+def get_player_specific_ids(mod_data, remap: dict[int, dict[str, list]]) -> (dict, list, dict):
+    try:
+        data_dict = json.loads(mod_data)
+    except Exception as e:
+        logger.warning(f"Failed to extract player specific IDs: {e}")
+        return {}, [], {}
 
-    data_dict = json.loads(mod_data)
+    flat_songs = {song[1]: song[0] for pack, songs in data_dict.items() for song in songs}
+    conflicts = remap.keys() & flat_songs.keys()
 
-    for pack_name, songs in data_dict.items():
-        for song in songs:
-            song_id = song[1]
-            song_ids.append(song_id)
+    player_remapped = {}
+    for song_id in conflicts:
+        name = format_song_name(flat_songs[song_id], song_id)
+        if name in remap[song_id]:
+            player_remapped.update({song_id: remap[song_id][name][0]})
 
-    return data_dict, song_ids  # Return the list of song IDs
+    return data_dict, list(flat_songs.keys()), player_remapped  # Return the list of song IDs
diff --git a/MegaMixCollection.py b/MegaMixCollection.py
index 7c654d2..1a7027c 100644
--- a/MegaMixCollection.py
+++ b/MegaMixCollection.py
@@ -1,13 +1,16 @@
 # Local
 from .Items import SongData
-from .SymbolFixer import fix_song_name
-from .MegaMixSongData import SONG_DATA
+from .SymbolFixer import format_song_name
+from .MegaMixSongData import SONG_DATA, base_game_ids, dlc_ids
 from .DataHandler import extract_mod_data_to_json
 
 # Python
 from typing import Dict, List
 from collections import ChainMap
+import logging
 
+logging.basicConfig(level=logging.DEBUG)
+logger = logging.getLogger(__name__)
 
 class MegaMixCollections:
     """Contains all the data of MegaMix, loaded from songData.json"""
@@ -40,18 +43,53 @@ class MegaMixCollections:
 
         self.song_items = SONG_DATA
         mod_data = extract_mod_data_to_json()
-        base_game_ids = {song_data.songID for song_data in SONG_DATA.values() if song_data.songID is not None}
+
+        self.mod_remaps: dict[int, dict[str, list]] = {}
 
         if mod_data:
+            seen_mod_song_ids = set()
+            seen_mod_item_ids = set()
+
             for data_dict in mod_data:
-                for _, songs in data_dict.items():
+                for pack, songs in data_dict.items():
                     for song in songs:
+                        if not isinstance(song, list) or not list(map(type, song)) == [str, int, int]:
+                            logger.warning("Skipping", pack, song)
+                            continue
+
                         song_id = song[1]
-                        song_name = f"{fix_song_name(song[0])} [{song_id}]"
-                        item_id = (song_id * 10)
-                        # If cover song
+
                         if song_id in base_game_ids:
-                            item_id += 1
+                            continue
+
+                        song_name = format_song_name(song[0], song_id)
+                        item_id = (song_id * 10)
+
+                        if song_name in self.song_items:
+                            logger.warning(f"{song_name} previously mapped to base ID, skipping")
+                            continue
+
+                        # Remap up to 4 ID conflicts using the 8 free slots (2-9) between item/loc IDs.
+                        if song_id in seen_mod_song_ids:
+                            if song_id in self.mod_remaps and song_name in self.mod_remaps[song_id]:
+                                logger.warning(f"{song_name} already remapped to {self.mod_remaps[song_id][song_name]}")
+                                continue
+
+                            resolve = {i for i in range(item_id + 2, item_id + 10)}
+                            resolve -= seen_mod_item_ids
+                            new_slots = sorted(resolve)[0:2]
+
+                            if len(new_slots) != 2:
+                                raise Exception(f"Could not remap conflict of {song_name} (out of slots)\n"
+                                                f"{self.mod_remaps[song_id]}")
+                            logger.warning(f"Remapped {song_name} to {new_slots}")
+
+                            item_id = new_slots[0]
+                            seen_mod_item_ids.update(new_slots)
+
+                            self.mod_remaps.setdefault(song_id, {})
+                            self.mod_remaps[song_id][song_name] = new_slots
+                        seen_mod_song_ids.add(song_id)
 
                         # Shift difficulty bitfields from modded data into [#,#,#,#,#]
                         diff_info = []
@@ -62,20 +100,14 @@ class MegaMixCollections:
                             diff_info.insert(0, diff + (.5 if half else 0.0))
                             song[2] >>= 5
 
-                        self.song_items[song_name] = SongData(item_id, song_id, [], False, True, diff_info)
+                        self.song_items[song_name] = SongData(item_id, song_id, set(), song_id in dlc_ids, True, diff_info)
 
         self.item_names_to_id.update({name: data.code for name, data in self.song_items.items()})
 
         for song_name, song_data in self.song_items.items():
-            if song_data.code % 2 != 0:  # Fix code for covers
-                for i in range(2):
-                    self.song_locations[f"{song_name}-{i}"] = (song_data.code + i - 1)
-                continue
-
             for i in range(2):
                 self.song_locations[f"{song_name}-{i}"] = (song_data.code + i)
 
-
     def get_songs_with_settings(self, dlc: bool, mod_ids: List[int], allowed_diff: List[int], diff_lower: float, diff_higher: float) -> List[str]:
         """Gets a list of all songs that match the filter settings. Difficulty thresholds are inclusive."""
         filtered_list = []
diff --git a/SymbolFixer.py b/SymbolFixer.py
index f05c0bd..34a0217 100644
--- a/SymbolFixer.py
+++ b/SymbolFixer.py
@@ -125,3 +125,7 @@ def fix_song_name(song_name):
     cleaned_song_name = replace_non_ascii_with_space(cleaned_song_name)  # After conversion, replace any remainders with blanks
     cleaned_song_name = special_char_removal(cleaned_song_name)
     return cleaned_song_name
+
+
+def format_song_name(name: str, song_id: int):
+    return f"{fix_song_name(name)} [{song_id}]"
diff --git a/__init__.py b/__init__.py
index 4a42316..a819d9a 100644
--- a/__init__.py
+++ b/__init__.py
@@ -84,6 +84,7 @@ class MegaMixWorld(World):
 
     topology_present = False
     web = MegaMixWebWorld()
+    ut_can_gen_without_yaml = True
 
     # Necessary Data
     mm_collection = MegaMixCollections()
@@ -95,8 +96,9 @@ class MegaMixWorld(World):
     item_name_groups = mm_collection.get_item_name_groups()
 
     # Working Data
-    player_specific_mod_data = {}
-    player_specific_ids = {}
+    player_mod_data = {}
+    player_mod_ids = {}
+    player_mod_remap = {}
     victory_song_name: str = ""
     victory_song_id: int
     starting_songs: List[str] = []
@@ -110,6 +112,25 @@ class MegaMixWorld(World):
         if re_gen_passthrough and self.game in re_gen_passthrough:
             slot_data: dict[str, any] = re_gen_passthrough[self.game]
 
+            # Inject mod data, remap as needed
+            from .SymbolFixer import format_song_name
+            from .Items import SongData
+            for pack, items in slot_data.get("modData", {}).items():
+                for item in items: # for name, song_id in items
+                    # Temporary back-compat for testing on older world gens
+                    name = item[0] if len(item) == 2 else "Modded Song"
+                    song_id = item[-1]
+
+                    formatted_name = format_song_name(name, song_id)
+
+                    remap = slot_data.get("modRemap", {})
+                    item_id = remap.get(str(song_id), song_id * 10)
+
+                    self.mm_collection.song_items[formatted_name] = SongData(item_id, song_id, set(), False, True, [])
+                    for i in range(2):
+                        self.mm_collection.song_locations[f"{formatted_name}-{i}"] = (item_id + i)
+            self.item_id_to_name.update({data.code: name for name, data in self.mm_collection.song_items.items()})
+
             if "finalSongIDs" in slot_data:
                 final = slot_data.get("finalSongIDs", [])
                 self.included_songs = [key for key, song in self.mm_collection.song_items.items() if song.songID in final]
@@ -119,13 +140,13 @@ class MegaMixWorld(World):
         # Initial search criteria
         lower_rating_threshold, higher_rating_threshold = self.get_difficulty_range()
         lower_diff_threshold, higher_diff_threshold = self.get_available_difficulties(self.options.song_difficulty_min.value, self.options.song_difficulty_max.value)
-        self.player_specific_mod_data, self.player_specific_ids = get_player_specific_ids(self.options.megamix_mod_data.value)
+        self.player_mod_data, self.player_mod_ids, self.player_mod_remap = get_player_specific_ids(self.options.megamix_mod_data.value, self.mm_collection.mod_remaps)
 
         while True:
             # In most cases this should only need to run once
 
             allowed_difficulties = list(range(lower_diff_threshold, higher_diff_threshold + 1))
-            available_song_keys = self.mm_collection.get_songs_with_settings(self.options.allow_megamix_dlc_songs, self.player_specific_ids, allowed_difficulties, lower_rating_threshold, higher_rating_threshold)
+            available_song_keys = self.mm_collection.get_songs_with_settings(bool(self.options.allow_megamix_dlc_songs.value), self.player_mod_ids, allowed_difficulties, lower_rating_threshold, higher_rating_threshold)
 
             available_song_keys = self.handle_plando(available_song_keys)
             #print(f"{lower_rating_threshold}~{higher_rating_threshold}* {allowed_difficulties}", len(available_song_keys))
@@ -170,9 +191,9 @@ class MegaMixWorld(World):
 
         # The ModdedSongs group is shared across all players. Limit to own songs.
         self.starting_songs = [s for s in start_items if s in song_items and
-                               not song_items.get(s).modded or song_items.get(s).songID in self.player_specific_ids]
+                               not song_items.get(s).modded or song_items.get(s).songID in self.player_mod_ids]
         included_songs = [s for s in include_songs if s in song_items and s not in self.starting_songs and
-                               not song_items.get(s).modded or song_items.get(s).songID in self.player_specific_ids]
+                               not song_items.get(s).modded or song_items.get(s).songID in self.player_mod_ids]
 
         # Handle goal before inc%
         if goal_songs:
@@ -238,7 +259,7 @@ class MegaMixWorld(World):
                 self.included_songs.append(available_song_keys.pop())
 
         victory_song = self.mm_collection.song_items.get(self.victory_song_name)
-        self.victory_song_id = victory_song.code
+        self.victory_song_id = (victory_song.code // 10) * 10
         self.final_song_ids.add(victory_song.songID)
         self.location_count = 2 * (len(self.starting_songs) + len(self.included_songs))
 
@@ -348,8 +369,8 @@ class MegaMixWorld(World):
         # Generate the number_to_option_value dictionary using the formula
         number_to_option_value = {i: 1 + i * 0.5 if i % 2 != 0 else int(1 + i * 0.5) for i in range(19)}
 
-        minimum_difficulty = number_to_option_value.get(self.options.song_difficulty_rating_min, None)
-        maximum_difficulty = number_to_option_value.get(self.options.song_difficulty_rating_max, None)
+        minimum_difficulty = number_to_option_value.get(self.options.song_difficulty_rating_min.value, None)
+        maximum_difficulty = number_to_option_value.get(self.options.song_difficulty_rating_max.value, None)
         difficulty_bounds = [min(minimum_difficulty, maximum_difficulty), max(minimum_difficulty, maximum_difficulty)]
 
         return difficulty_bounds
@@ -378,6 +399,7 @@ class MegaMixWorld(World):
             "autoRemove": bool(self.options.auto_remove_songs),
             "deathLink": self.options.death_link.value,
             "deathLink_Amnesty": self.options.death_link_amnesty.value,
-            "modData": {pack: [song[1] for song in songs if song[1] in self.final_song_ids]
-                        for pack, songs in self.player_specific_mod_data.items()},
+            "modData": {pack: [[song[0], song[1]] for song in songs if song[1] in self.final_song_ids]
+                        for pack, songs in self.player_mod_data.items()},
+            "modRemap": self.player_mod_remap,
         }
