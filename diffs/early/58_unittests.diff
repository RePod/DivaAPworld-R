diff --git a/test/test_client_pv_db.py b/test/test_client_pv_db.py
new file mode 100644
index 0000000..0c4cce2
--- /dev/null
+++ b/test/test_client_pv_db.py
@@ -0,0 +1,46 @@
+from . import MegaMixTestBase
+from ..DataHandler import modify_mod_pv, remove_song
+
+class TestClientPVDB(MegaMixTestBase):
+
+    def test_modify_mod_pv(self):
+        """Verify modify_mod_pv will only enable given IDs."""
+        start = """#ARCH#pv_123.difficulty.extreme.length=1
+        #ARCH#pv_124.difficulty.extreme.length=1
+        pv_125.difficulty.extreme.length=1"""
+
+        good = """pv_123.difficulty.extreme.length=1
+        #ARCH#pv_124.difficulty.extreme.length=1
+        pv_125.difficulty.extreme.length=1"""
+
+        result = modify_mod_pv(start, "123")
+
+        self.assertMultiLineEqual(good, result)
+
+    def test_remove_song(self):
+        """Verify remove_song will only disable given IDs."""
+        start = """pv_123.difficulty.extreme.length=1
+        pv_124.difficulty.extreme.length=1
+        #ARCH#pv_125.difficulty.extreme.length=1"""
+
+        good = """#ARCH#pv_123.difficulty.extreme.length=1
+        pv_124.difficulty.extreme.length=1
+        #ARCH#pv_125.difficulty.extreme.length=1"""
+
+        result = remove_song(start, "123")
+
+        self.assertMultiLineEqual(good, result)
+
+    def test_remove_song_required(self):
+        """Verify remove_song will not touch IDs that are required to stay enabled."""
+        start = """#ARCH#pv_123.difficulty.extreme.length=1
+        pv_124.difficulty.extreme.length=1
+        pv_144.difficulty.extreme.length=1
+        pv_700.difficulty.extreme.length=1"""
+
+        # These should all achieve the same thing: nothing.
+        result = remove_song(start, "144")
+        result = remove_song(result, "700")
+        result = remove_song(result, "144|700")
+
+        self.assertMultiLineEqual(start, result)
diff --git a/test/test_difficulty_expansion.py b/test/test_difficulty_expansion.py
new file mode 100644
index 0000000..6a8c3af
--- /dev/null
+++ b/test/test_difficulty_expansion.py
@@ -0,0 +1,59 @@
+from . import MegaMixTestBase
+
+# The song difficulty search expansion goes as follows:
+#   Current min/max Diff, current min/max ratings
+#     lower min rating until 1 then raise max rating until 10
+#   Lower min Diff, reset min/max ratings
+#     lower min rating until 1 then raise max until 10
+#   Raise max Diff, reset min/max ratings
+#     lower min rating until 1 then raise max until 10
+# Given the opportunity it can expand down to Easy 1 and up to Extra Extreme 10... all to find 30 songs.
+
+class TestWorstCaseEasyUp(MegaMixTestBase):
+    # No DLC + Easy~Easy + 1*~1* = 7 out of 140 Easy
+    # Easy starts at 1* so this should expand upwards.
+    options = {
+        "starting_song_count": 10,
+        "allow_megamix_dlc_songs": False,
+        "song_difficulty_min": 'easy',
+        "song_difficulty_max": 'easy',
+        "song_difficulty_rating_min": 'one',
+        "song_difficulty_rating_max": 'one',
+    }
+
+class TestWorstCaseEasyDown(MegaMixTestBase):
+    # No DLC + Easy~Easy + 4.5*~4.5* = 1 out of 140 Easy
+    # Easy ends at 4.5* so this should expand downwards.
+    options = {
+        "starting_song_count": 10,
+        "allow_megamix_dlc_songs": False,
+        "song_difficulty_min": 'easy',
+        "song_difficulty_max": 'easy',
+        "song_difficulty_rating_min": '4x5',
+        "song_difficulty_rating_max": '4x5',
+    }
+
+class TestWorstCaseExExtremeDown(MegaMixTestBase):
+    # No DLC + ExEx~ExEx + 10*~10* = 6 out of 80 ExEx
+    # This should expand downwards.
+    options = {
+        "starting_song_count": 10,
+        "allow_megamix_dlc_songs": False,
+        "song_difficulty_min": 'exextreme',
+        "song_difficulty_max": 'exextreme',
+        "song_difficulty_rating_min": 'ten',
+        "song_difficulty_rating_max": 'ten',
+    }
+
+class TestWorstCaseExExtremeUp(MegaMixTestBase):
+    # No DLC + ExEx~ExEx + 7*~7* = 1 out of 80 ExEx
+    # ExEx starts at 6* but the lowest non-DLC song starts at 7*
+    # This should expand upwards (after bottoming out ExEx).
+    options = {
+        "starting_song_count": 10,
+        "allow_megamix_dlc_songs": False,
+        "song_difficulty_min": 'exextreme',
+        "song_difficulty_max": 'exextreme',
+        "song_difficulty_rating_min": 'seven',
+        "song_difficulty_rating_max": 'seven',
+    }
diff --git a/test/test_id_in_names.py b/test/test_id_in_names.py
new file mode 100644
index 0000000..2d9972f
--- /dev/null
+++ b/test/test_id_in_names.py
@@ -0,0 +1,53 @@
+import re
+
+from . import MegaMixTestBase
+
+
+class IDNames(MegaMixTestBase):
+    """Test that item/location names contain a song ID then verify that ID matches its item/loc ID."""
+    item_regex = r"(.*?) \[(\d+)\]$" # name, ID
+    location_regex = r"(.*?) \[(\d+)\]-(\d+)$" # name, ID, suffix
+
+    def test_item_names_have_id(self):
+        """Test all song item names include *a* song ID.
+        As of writing, song item IDs start at 10. 1-9 are reserved for non-song items."""
+        world = self.get_world()
+
+        quick = [name for name, locID in world.item_name_to_id.items() if not re.search(self.item_regex, name) and locID >= 10]
+        self.assertEqual(0, len(quick), f"Item names without song IDs: {quick}")
+
+    def test_loc_names_have_id(self):
+        """Test all location names include *a* song ID."""
+        world = self.get_world()
+
+        quick = [name for name in world.location_name_to_id if not re.search(self.location_regex, name)]
+        self.assertEqual(0, len(quick), f"Location names without song IDs: {quick}")
+
+    def test_verify_item_names_for_id(self):
+        """Verify the ID in an item name matches its item ID.
+        As of writing, items IDs are originalSongID*10."""
+        world = self.get_world()
+
+        for name, itemID in world.item_name_to_id.items():
+            if itemID < 10:
+                continue
+
+            match = re.match(self.item_regex, name)
+            self.assertIsNotNone(match, f"Failed to match item_regex to item name: {name}")
+
+            given_id = int(match.group(2))
+
+            self.assertEqual(given_id, (itemID // 10), f"Song ID in item name does not match item ID: {name}")
+
+    def test_verify_loc_names_for_id(self):
+        """Verify the ID in a location name matches its location ID.
+        As of writing, location IDs are originalSongID*10."""
+        world = self.get_world()
+
+        for name, locID in world.location_name_to_id.items():
+            match = re.match(self.location_regex, name)
+            self.assertIsNotNone(match, f"Failed to match location_regex to location name: {name}")
+
+            given_id = int(match.group(2))
+
+            self.assertEqual(given_id, (locID // 10), f"Song ID in location name does not match location ID: {name}")
diff --git a/test/test_options.py b/test/test_options.py
new file mode 100644
index 0000000..7178f86
--- /dev/null
+++ b/test/test_options.py
@@ -0,0 +1,64 @@
+from typing import ClassVar
+
+from test.param import classvar_matrix
+from . import MegaMixTestBase
+
+
+class TestOptionIncludes(MegaMixTestBase):
+    """Set include_songs and test the multiworld item pool for their inclusion."""
+    options = {
+        "allow_megamix_dlc_songs": True,
+        "duplicate_song_percentage": 0,
+        "include_songs": ["Love is War [1]", "Packaged [10]", "Senbonzakura [216]", "Teo [271]"],
+        "starting_song_count": 3,
+        "additional_song_count": 15,
+    }
+
+    def test_included(self):
+        world = self.get_world()
+        pool = {song.name for song in world.multiworld.itempool if song.code >= 10}
+
+        self.assertTrue(set(world.options.include_songs).issubset(pool))
+
+
+class TestOptionExcludes(MegaMixTestBase):
+    """Set exclude_songs and test the multiworld item pool for their absence."""
+    options = {
+        "allow_megamix_dlc_songs": True,
+        "duplicate_song_percentage": 0,
+        "exclude_songs": ["Love is War [1]", "Packaged [10]", "Senbonzakura [216]", "Teo [271]"],
+        "starting_song_count": 10,
+        "additional_song_count": 251,
+    }
+
+    def test_excluded(self):
+        world = self.get_world()
+        pool = {song.name for song in world.multiworld.itempool if song.code >= 10}
+
+        self.assertFalse(set(world.options.exclude_songs).issubset(pool))
+
+
+# Can also supply combinations.
+@classvar_matrix(singer=[{'Hatsune Miku'}, {'Kagamine Rin'}, {'Kagamine Len'}, {'Megurine Luka'}, {'KAITO'}, {'MEIKO'}])
+class TestOptionExcludeSinger(MegaMixTestBase):
+    """Set exclude_singers and test the multiworld item pool for their absence."""
+    auto_construct = False
+    singer: ClassVar[set[str]]
+    options = {
+        "allow_megamix_dlc_songs": True,
+        "additional_song_count": 251,
+    }
+
+    def test_exclude_singer(self):
+        self.options["exclude_singers"] = self.singer
+        self.world_setup()
+
+        world = self.get_world()
+        # WARNING: mm_collection.song_items is subject to available megamix_mod_data
+        singer_songs = [song for song, prop in self.world.mm_collection.song_items.items() if set(prop.singers).intersection(world.options.exclude_singers)]
+        pool = {song.name for song in self.world.multiworld.itempool if song.code >= 10}
+        pool.update(world.starting_songs)
+
+        intersect = pool.intersection(singer_songs)
+        self.assertEqual(intersect, set(), f"0 songs from {world.options.exclude_singers} expected, got {len(intersect)}: {intersect}")
+        self.assertEqual(len(singer_songs) + len(pool) + 1, len(self.world.mm_collection.song_items))
diff --git a/test/test_plando.py b/test/test_plando.py
new file mode 100644
index 0000000..38f439e
--- /dev/null
+++ b/test/test_plando.py
@@ -0,0 +1,40 @@
+from . import MegaMixTestBase
+from ..Options import IncludeSongs, ExcludeSongs
+
+class TestPlando(MegaMixTestBase):
+    """Test the handle_plando function directly.
+    See also: test_options"""
+
+    def _test_plando(self, exclude: bool = False):
+        """Shuffle song_items, pick out 60, allocate 30 to include/exclude, verify they're not returned."""
+
+        world = self.get_world()
+        song_items = world.mm_collection.song_items
+
+        self.assertGreaterEqual(len(song_items), 60, f"Minimum 60 MMC song_items expected, got {len(song_items)}")
+
+        items = list(song_items)
+        world.random.shuffle(items)
+        items = items[0:60]
+        extras = items[-30:]
+        candidates = items[0:30]
+
+        self.assertEqual(30, len(candidates), f"30 candidates expected, got {len(candidates)}")
+        self.assertEqual(30, len(extras), f"30 extras expected, got {len(extras)}")
+
+        if exclude:
+            world.options.exclude_songs = ExcludeSongs(candidates)
+        else:
+            world.options.include_songs = IncludeSongs(candidates)
+
+        song_pool = world.handle_plando(items)
+        overlap = [song for song in candidates if song in song_pool]
+
+        self.assertEqual(0, len(overlap), f"0 overlap expected, got {len(overlap)}")
+        self.assertEqual(len(extras), len(song_pool), f"{len(extras)} remaining in song pool expected, got {len(song_pool)}")
+
+    def test_plando_include(self):
+        self._test_plando()
+
+    def test_plando_exclude(self):
+        self._test_plando(True)
diff --git a/test/test_victory_song.py b/test/test_victory_song.py
new file mode 100644
index 0000000..89491a0
--- /dev/null
+++ b/test/test_victory_song.py
@@ -0,0 +1,22 @@
+from . import MegaMixTestBase
+
+class TestVictorySong(MegaMixTestBase):
+
+    def test_victory_song_id(self):
+        """Match the Victory Song ID back to its MMC self by name"""
+        world = self.get_world()
+
+        id_victory = world.item_name_to_id.get(world.victory_song_name)
+        id_mmc = world.mm_collection.song_items.get(world.victory_song_name).code
+
+        self.assertEqual(id_victory, id_mmc, "Victory Song code and MMC song code do not match")
+
+    def test_victory_song_name(self):
+        """Match the Victory Song name back to its MMC self by ID"""
+        world = self.get_world()
+
+        song_items = world.mm_collection.song_items
+        name_victory = world.item_id_to_name.get(world.victory_song_id)
+        name_mmc = [song for song in song_items if song_items[song].code == world.victory_song_id].pop()
+
+        self.assertEqual(name_victory, name_mmc, "Victory Song name and MMC song name do not match")
